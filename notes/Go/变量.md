# 变量
## 变量是什么?为什么需要变量？
1. 编程的本质是对内存中数据的访问和修改。程序所用的数据都会保存在内存中，程序员需要一种机制来访问和修改保存在内存中数据。这种机制就是变量。每个变量都代表了某一小块内存，而且变量都是有名字的，程序对变量赋值，实际上就是把数据装入该变量的内存区域的 ；程序读取的值实际上就是把该变量所代表的内存区取值的过程。

    形象理解为：变量相当于一个有名称的容器，该容器用于存储各种类型的数据。

2. 变量是程序的基本组成单位 
    不论是使用哪种高级程序语言编写程序,变量都是其程序的基本组成单位
## 变量概述
变量相当于内存中一个数据存储空间的表示。

变量使用的基本步骤：
1. 声明变量(也称定义变量) 
2. 变量赋值 
3. 变量使用
## 定义变量

Go语言里面定义变量有多种方式。

### var 定义单个变量

使用var关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面：
```
//定义一个名称为“variableName”，类型为"type"的变量
var variableName type
```
### 定义多个变量
```
//定义三个类型都是“type”的变量
var vname1, vname2, vname3 type
```
### 定义变量并初始化值
```
//初始化“variableName”的变量为“value”值，类型是“type”
var variableName type = value
```
### 同时定义并初始化多个变量
```
/*
    定义三个类型都是"type"的变量,并且分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
*/
var vname1, vname2, vname3 type= v1, v2, v3
```
**简化方式：**
1. 直接忽略类型声明：
```
/*
    定义三个变量，它们分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
    然后Go会根据其相应值的类型来帮你初始化它们
*/
var vname1, vname2, vname3 = v1, v2, v3
```
2. 简短声明 := 
```
/*
    定义三个变量，它们分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
    编译器会根据初始化的值自动推导出相应的类型
*/
vname1, vname2, vname3 := v1, v2, v3
```
:=这个符号直接取代了var和type,这种形式叫做简短声明。**不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用var方式来定义全局变量。**
### _（下划线）
_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，我们将值35赋予b，并同时丢弃34：
```
_, b := 34, 35
```
## 注意事项：
1. Go对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了i但未使用。
    ```
    package main

    func main() {
        var i int
    }
    ```
2. 变量在同一个作用域(在一个函数或者在代码块)内不能重名

3. 变量三要素：变量=变量名+值+数据类型，这一点需要格外注意。

4. Golang的变量的零值
    Golang的变量如果没有赋初值，编译器会使用默认值, 比如 int 默认值 0 string默认值为空串.

## 变量的生命周期
变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的声明周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

### Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？
基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。