# 函数
## 函数定义：
为完成某一功能的程序指令(语句)的集合,称为函数。

在Go中,函数分为: 自定义函数、系统函数(查看Go编程手册)

## 基本语法
```
func 函数名（形参列表）（返回值列表）{
    执行语句...
    return 返回值列表
}
```
参数说明：
形参列表：表示函数的输入
函数中的语句：表示为了实现某一功能代码块
函数可以有返回值,也可以没有
## 函数调用
函数调用的机制和原则:
- 当编译器执行调用函数时，就会开辟一个新的数据空间,
- 该空间的独立[是编译器处理]
- 各个数据空间在栈中。
### 多个返回值
```
//返回 A+B 和 A*B
func SumAndProduct(A, B int) (int, int) {
	return A+B, A*B
}
```
官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。
```
func SumAndProduct(A, B int) (add int, Multiplied int) {
	add = A+B
	Multiplied = A*B
	return
}
```

### 变参
Go函数支持变参。接受变参的函数是有着不定数量的参数的
```
func myfunc(arg ...int) {}
```
arg ...int告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是int。在函数体中，变量arg是一个int的slice：
```
for _, n := range arg {
	fmt.Printf("And the number is: %d\n", n)
}
```

### 递归调用
一个函数在函数体内又调用了本身，我们称为递归调用
```
/*
斐波那契数
（斐波那契数列由 0 和 1 开始，之后的斐波那契数列系数就由之前的两数相加。注：0不是第一项，而是第零项）
请使用递归的方式，求出斐波那契数1,1,2,3,5,8,13...
给你一个整数n，求出它的斐波那契数是多少？
分析：
1、当n=1 和 n=2 时，斐波那契数数是1
2、从n=3开始，斐波那契数数是前两个数之和
*/

func Fbnqs(n int) int {

    if n == 1 ||  n == 2 {
        return 1
    }else{
        return Fbnqs(n-1) + Fbnqs(n-2)
    }


}

```
**函数递归需要遵守的重要原则:**
1. 执行一个函数时，就创建一个新的受保护的独立空间(新函数栈) 
2. 函数的局部变量是独立的，不会相互影响；如果希望各个函数栈使用同一个数据，则可以使用全局变量和引用传递（推荐）。 
3. 递归必须向退出递归的条件逼近，否则就是无限递归，变死龟了。 
4. 当一个函数执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当函数执行完毕或者返回时，该函数本身也会被系统销毁

## 函数参数的传递
1. 基本数据类型和数组默认都是值传递的，即进行值拷贝。在函数内修改，不会影响到原来的值。
2. 值类型参数默认就是值传递，而引用类型参数默认就是引用传递。

### 值传递
当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。
```
//简单的一个函数，实现了参数+1的操作
func add1(a int) int {
	a = a+1 // 我们改变了a的值
	return a //返回一个新值
}

func main() {
	x := 3

	fmt.Println("x = ", x)  // 应该输出 "x = 3"

	x1 := add1(x)  //调用add1(x)

	fmt.Println("x+1 = ", x1) // 应该输出"x+1 = 4"
	fmt.Println("x = ", x)    // 应该输出"x = 3"
}
```
### 指针传递
```
//简单的一个函数，实现了参数+1的操作
func add1(a *int) int { // 请注意，
	*a = *a+1 // 修改了a的值
	return *a // 返回新值
}

func main() {
	x := 3

	fmt.Println("x = ", x)  // 应该输出 "x = 3"

	x1 := add1(&x)  // 调用 add1(&x) 传x的地址

	fmt.Println("x+1 = ", x1) // 应该输出 "x+1 = 4"
	fmt.Println("x = ", x)    // 应该输出 "x = 4"
}
```

指针传递好处：
- 传指针使得多个函数能操作同一个对象。
- 传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。
- Go语言中channel，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）

## 匿名函数
### 基本介绍
Go支持匿名函数，如果我们某个函数只是希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用。
### 匿名函数使用方式
1. 在定义匿名函数时就直接调用， 
```
// 在定义匿名函数时就直接调用
func Anonymous1(n1 ,n2 int) int  {
    /*定义匿名函数
    func (num1 ,num2 int) int  {
        return num1 + num2
    }
    */
    res := func (num1 ,num2 int) int  {
        return num1 + num2
    }(n1,n2)
    return res
}

```
2. 将匿名函数赋给一个变量(函数变量)，再通过该变量来调用匿名函数 
```
// 将匿名函数赋给一个变量(函数变量)，再通过该变量来调用匿名函数
func Anonymous2(n1 ,n2 int) int   {
    Anony := func (num1 ,num2 int) int  {
        return num1 + num2
    }
    return Anony(n1,n2)
}

```
3. 全局匿名函数 
    如果将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序有效。 
```
// 如果将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序有效。
var Anonymous3 = func (n1 ,n2 int) int   {
    return n1+n2
}
```

## 闭包
### 基本介绍
闭包就是一个函数和与其相关的引用环境组合的一个整体(实体)
### 使用
```
func AddUpper(str string) func (int) int {
    var n int = 10
    //var str string = "tom~"
    return func(x int) int {
        n = n + x
        str += " hello "
        fmt.Println("str=", str)
        return n
    }

}

func main() {

    f := AddUpper("jack") // f就是一个函数 func (int) int
    fmt.Println(f(1)) // 11  jack hello
    fmt.Println(f(2)) // 13   jack hello hello
    fmt.Println(f(3)) // 16   jack hello hello hello

}

```
**案例分析：**

1. AddUpper会返回一个匿名函数
```
func(x int) int {
        n = n + x
        return n
    }
```
2. 该匿名函数引用到其函数外部一个变n
```
var n int = 10
    return func(x int) int {
        n = n + x
        return n
    }
```
3. 你匿名函数和它引用到的外部变量n,形成一个整体，构成一个闭包。

4. f(1) , f(2) …即在反复调用闭包。

5. 当我们使用闭包时，该匿名函数引用到外部n， 只会被初始化一次，以后调用时，则使用同一n.。

6. 你可以这样理解，把闭包看成一个类，匿名函数就相当于方法，而引用到的外部变量就是字段。

7. 搞清楚闭包的关键点，就是分析出，该匿名函数引用到外部变量是哪些。
