# Go 笔试

## new和make的区别
Go语言中new和make是内建的两个函数，主要用来创建分配类型内存。
- new 返回的永远是类型的指针，指向分配类型的内存地址
- make只用于chan、map以及切片的内存创建，而且它返回的类型就是类型本身。
## 数组和切片区别

Go语言的数组底层实现就是一段连续的内存空间。每个元素有唯一一个索引(或者叫下标)来访问。

切片有三个属性字段：长度、容量和指向数组的指针。

区别：
- 数组是固定大小;切片不是动态数组，可以扩容
- 定义方式不一样
    ```
    数组定义
    var a1 [3]int
    var a2 [...]int{1,2,3}
    切片定义
    var b1 []int
    b2 := make([]int, 3, 5)
    ```
- 初始化方法不一样
    ```
    数组
    a1 := [...]int{1,2,3}
    a2 := [5]int{1,2,3}
    切片
    b1 := make([]int, 3,5)
    ```
slice是如何扩容的规则：

- 如果切片的容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。
- 如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。
## 进程、线程和协程区别
进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。

线程是程序中一个单一的顺序控制流程。进程内有一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指令运行时的程序的调度单位

协程与子例程一样，协程（coroutine）也是一种程序组件。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。 

协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。 

一个程序可以包含多个协程，可以对比与一个进程包含多个线程， 

因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。 

协程和线程区别：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。
## go select 关键字
select是Golang在语言层面提供的多路IO复用的机制.

select用法类似于switch语句，用于处理异步IO操作。select会监听case语句中channel的读写操作，当case中channel读写操作为非阻塞状态（即能读写）时，将会触发相应的动作。

select中的case语句必须是一个channel操作

select中的default子句总是可运行的。

如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行。
如果没有可运行的case语句，且有default语句，那么就会执行default的动作。
如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行
> select中优先级问题,使用default实现

## GoStub

## 理解Go中协程

## channel 特性

## go 同步锁机制
sync.Mutex：互斥锁
 sync.RWMutex： 读写锁